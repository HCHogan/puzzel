{-# LANGUAGE TemplateHaskell #-}

module HM.Infer.Offline where

import Control.Lens
import Control.Monad
import Effectful
import Effectful.Dispatch.Static
import Effectful.Error.Static
import Effectful.Reader.Static
import Effectful.State.Static.Local
import Effectful.Writer.Static.Local

import Data.List (nub)
import Data.Map qualified as M
import Data.Set qualified as S

import HM.Infer.Subst
import HM.Infer.TypeEnv
import HM.Infer.TypeError
import HM.Syntax
import HM.Type

-- In InferC.hs, we will use contraint generation approach.
-- Constraints are generated by bottom-up traversal, added to a ordered container
-- canonicalized, solved, and then possibly back-substituted over a typed AST.
-- Using seperate constraint solver becomes easier to manage as our type system gets more complex.

-- inference monad:
-- Eff [Reader Env, Writer [Constraint], State InferState, Error TypeError] a

newtype InferState = InferState {_count :: Int}
  deriving (Show)

makeLenses ''InferState

initInfer :: InferState
initInfer = InferState{_count = 0}

type Constraint = (Type, Type)

-- TODO:
lookupEnv :: (State InferState :> es, Reader TypeEnv :> es, Error TypeError :> es) => Var -> Eff es Type
lookupEnv x = do
  (TypeEnv e) <- ask
  case M.lookup x e of
    Nothing -> throwError_ $ UnboundVariable x
    Just s -> instantiate s

-- | Canonicalize and return the polymorphic toplevel type.
closeOver :: Type -> Scheme
closeOver = normalize . generalize emptyTypeEnv

instantiate :: (State InferState :> es) => Scheme -> Eff es Type
instantiate (Forall as t) = do
  as' <- mapM (const fresh) as
  let s = M.fromList $ zip as as'
  return $ apply s t

generalize :: TypeEnv -> Type -> Scheme
generalize env t = Forall as t
 where
  as = S.toList $ ftv t `S.difference` ftv env

normalize :: Scheme -> Scheme
normalize (Forall _ body) = Forall (map snd ord) (normtype body)
 where
  ord = zip (nub $ fv body) (map TV letters)

  fv (TVar a) = [a]
  fv (TArr a b) = fv a ++ fv b
  fv (TCon _) = []

  normtype (TArr a b) = TArr (normtype a) (normtype b)
  normtype (TCon a) = TCon a
  normtype (TVar a) =
    case Prelude.lookup a ord of
      Just x -> TVar x
      Nothing -> error "type variable not in signature"

bind :: (Error TypeError :> es) => TVar -> Type -> Eff es Subst
bind a t
  | t == TVar a = return nullSubst
  | occursCheck a t = throwError_ $ InfiniteType a t
  | otherwise = return (M.singleton a t)

occursCheck :: (Substitutable a) => TVar -> a -> Bool
occursCheck a t = a `S.member` ftv t

letters :: [String]
letters = [1 ..] >>= flip replicateM ['a' .. 'z']

fresh :: (State InferState :> es) => Eff es Type
fresh = do
  idx <- gets (^. count)
  modify (count +~ 1)
  return $ TVar $ TV (letters !! idx)

ops :: M.Map Binop Type
ops =
  M.fromList
    [ (Add, TArr typeInt (TArr typeInt typeInt))
    , (Mul, TArr typeInt (TArr typeInt typeInt))
    , (Sub, TArr typeInt (TArr typeInt typeInt))
    , (Eql, TArr typeInt (TArr typeInt typeBool))
    ]

-- extend type env
inEnv :: (HasCallStack, Reader TypeEnv :> es) => (Var, Scheme) -> Eff es a -> Eff es a
inEnv (x, sc) = local (\e -> remove e x `extend` (x, sc))

inferTop :: TypeEnv -> [(String, Expr)] -> Either TypeError TypeEnv
inferTop env [] = Right env
inferTop env ((name, ex) : xs) = case inferExpr env ex of
  Left err -> Left err
  Right ty -> inferTop (extend env (name, ty)) xs

-- | Solve for the toplevel type of an expression in a given environment
inferExpr :: TypeEnv -> Expr -> Either TypeError Scheme
inferExpr env ex = case runInfer env (infer ex) of
  Left err -> Left err
  Right (ty, cs) -> case runSolve cs of
    Left err -> Left err
    Right subst -> Right $ closeOver $ apply subst ty

runInfer :: TypeEnv -> Eff [State InferState, Reader TypeEnv, Error TypeError] (Type, [Constraint]) -> Either TypeError (Type, [Constraint])
runInfer e m = runPureEff $ runErrorNoCallStack $ runReader e $ evalState initInfer m

infer :: (HasCallStack, Reader TypeEnv :> es, State InferState :> es, Error TypeError :> es) => Expr -> Eff es (Type, [Constraint])
infer = \case
  Lit (LInt _) -> return (typeInt, [])
  Lit (LBool _) -> return (typeBool, [])
  Var x -> do
    t <- lookupEnv x
    return (t, [])
  Lam x e -> do
    tv <- fresh
    (t, c) <- inEnv (x, Forall [] tv) (infer e)
    return (TArr tv t, c)
  App e1 e2 -> do
    (t1, c1) <- infer e1
    (t2, c2) <- infer e2
    tv <- fresh
    return (tv, c1 ++ c2 ++ [(t1, TArr t2 tv)])
  Let x e1 e2 -> do
    env <- ask @TypeEnv
    (t1, c1) <- infer e1
    case runSolve c1 of
      Left err -> throwError_ err
      Right sub -> do
        let sc = generalize (apply sub env) (apply sub t1)
        (t2, c2) <- inEnv (x, sc) $ local @TypeEnv (apply sub) (infer e2)
        return (t2, c1 ++ c2)
  Fix e1 -> do
    (t1, c1) <- infer e1
    tv <- fresh
    return (tv, (t1, TArr tv tv) : c1)
  Op op e1 e2 -> do
    (t1, c1) <- infer e1
    (t2, c2) <- infer e2
    tv <- fresh
    let u1 = TArr t1 $ TArr t2 tv
    let u2 = ops M.! op
    return (tv, c1 ++ c2 ++ [(u1, u2)])
  If cond tr fl -> do
    (tcond, c1) <- infer cond
    (ttr, c2) <- infer tr
    (tfl, c3) <- infer fl
    return (ttr, c1 ++ c2 ++ [(ttr, tfl)])

-- Our solver monad:
-- type Solve a = StateT Unifier (ExceptT TypeError Identity) a

type Unifier = (Subst, [Constraint])

emptyUnifier :: Unifier
emptyUnifier = (nullSubst, [])

unifies :: (Error TypeError :> es) => Type -> Type -> Eff es Subst
unifies t1 t2 | t1 == t2 = return nullSubst
unifies (TVar v) t = v `bind` t
unifies t (TVar v) = v `bind` t
unifies (TArr t1 t2) (TArr t3 t4) = unifyMany [t1, t2] [t3, t4]
unifies t1 t2 = throwError_ $ UnificationFail t1 t2

unifyMany :: (Error TypeError :> es) => [Type] -> [Type] -> Eff es Subst
unifyMany [] [] = return nullSubst
unifyMany (t1 : ts1) (t2 : ts2) = do
  su1 <- unifies t1 t2
  su2 <- unifyMany (apply su1 ts1) (apply su1 ts2)
  return (su2 `compose` su1)
unifyMany t1 t2 = throwError_ $ UnificationMismatch t1 t2

solve :: (Error TypeError :> es) => Unifier -> Eff es Subst
solve (su, cs) = case cs of
  [] -> return su
  ((t1, t2) : cs0) -> do
    su1 <- unifies t1 t2
    solve (su1 `compose` su, apply su1 cs0)

runSolve :: [Constraint] -> Either TypeError Subst
runSolve cs = runPureEff $ runErrorNoCallStack $ solve (nullSubst, cs)
