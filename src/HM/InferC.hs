{-# LANGUAGE TemplateHaskell #-}

module HM.InferC where

import Control.Lens
import Effectful
import Effectful.Dispatch.Static
import Effectful.Error.Static
import Effectful.Reader.Static
import Effectful.State.Static.Local
import Effectful.Writer.Static.Local

import Data.Map qualified as M

import HM.Syntax
import HM.Type
import HM.TypeError

-- In InferC.hs, we will use contraint generation approach.
-- Constraints are generated by bottom-up traversal, added to a ordered container
-- canonicalized, solved, and then possibly back-substituted over a typed AST.
-- Using seperate constraint solver becomes easier to manage as our type system gets more complex.

-- inference monad:
-- Eff [Reader Env, Writer [Constraint], State InferState, Error TypeError] a

newtype InferState = InferState {_count :: Int}
  deriving (Show)

makeLenses ''InferState

type Constraint = (Type, Type)

newtype TypeEnv = TypeEnv (M.Map Var Scheme)

remove :: TypeEnv -> Var -> TypeEnv
remove (TypeEnv e) v = TypeEnv $ M.delete v e

extend :: TypeEnv -> (Var, Scheme) -> TypeEnv
extend (TypeEnv e) (x, s) = TypeEnv $ M.insert x s e

uni :: (HasCallStack, Writer [Constraint] :> es) => Type -> Type -> Eff es ()
uni t1 t2 = tell [(t1, t2)]

inEnv :: (HasCallStack, Reader TypeEnv :> es) => (Var, Scheme) -> Eff es a -> Eff es a
inEnv (x, sc) = local (\e -> remove e x `extend` (x, sc))

infer :: (HasCallStack, Reader TypeEnv :> es , Writer [Constraint] :> es, State InferState :> es, Error TypeError :> es) => Expr -> Eff es Type
infer = undefined

