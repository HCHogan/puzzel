{-# LANGUAGE TemplateHaskell #-}

module HM.InferC where

import Control.Lens
import Effectful
import Effectful.Dispatch.Static
import Effectful.Error.Static
import Effectful.Reader.Static
import Effectful.State.Static.Local
import Effectful.Writer.Static.Local

import Data.Map qualified as M

import HM.Type
import HM.Syntax

-- In InferC.hs, we will use contraint generation approach.
-- Constraints are generated by bottom-up traversal, added to a ordered container
-- canonicalized, solved, and then possibly back-substituted over a typed AST.
-- Using seperate constraint solver becomes easier to manage as our type system gets more complex.

-- inference monad:
-- Eff [Reader Env, Writer [Constraint], State InferState, Error TypeError] a

data InferState = InferState {_count :: Int}
  deriving (Show)

makeLenses ''InferState

type Constraint = (Type, Type)

newtype TypeEnv = TypeEnv (M.Map Var Scheme)

uni :: (HasCallStack, Writer [Constraint] :> es) => Type -> Type -> Eff es ()
uni t1 t2 = tell [(t1, t2)]

inEnv :: (HasCallStack, Reader TypeEnv :> es) => (Var, Scheme) -> Eff es a -> Eff es a
inEnv (x, sc) m = do
  undefined
  


